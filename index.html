<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jeu de plateau - Party Game</title>
<style>
  :root{
    --bg:#111;
    --panel:#0f0f0f;
    --accent:#f1c40f;
    --text:#eaeaea;
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);}
  .app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box;}
  /* Plateau area */
  .board-wrap{flex:1;position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,.7);}
  .board{max-width:100%;max-height:100%;display:block;width:100%;height:auto;}
  /* Right control panel */
  .panel{width:320px;background:linear-gradient(180deg,#0b0b0b,#121212);border-radius:8px;padding:16px;box-shadow:0 6px 20px rgba(0,0,0,.6);display:flex;flex-direction:column;gap:12px;}
  .panel h2{margin:0 0 6px 0;font-size:20px;color:var(--accent);}
  .players{display:flex;flex-wrap:wrap;gap:8px;}
  .pawn{width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.6);border:2px solid rgba(255,255,255,.06)}
  .pawn[data-selected="true"]{outline:3px solid rgba(241,196,15,.25);transform:translateY(-4px);}
  .controls{display:flex;gap:8px;align-items:center;}
  .btn{padding:8px 12px;background:#222;border-radius:8px;border:1px solid rgba(255,255,255,.04);cursor:pointer;color:var(--text);}
  .btn:disabled{opacity:.4;cursor:default}
  .select{padding:8px;border-radius:8px;background:#0b0b0b;color:var(--text);border:1px solid rgba(255,255,255,.04)}
  .dice{font-size:22px;padding:14px 18px;border-radius:10px;background:#161616;border:1px solid rgba(255,255,255,.03);cursor:pointer}
  .status{background:#080808;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.02);font-size:14px;min-height:64px}
  /* pawn elements on board */
  .pawn-on-board{position:absolute;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-size:12px;font-weight:700;box-shadow:0 4px 10px rgba(0,0,0,.6);transform:translate(-50%,-50%);pointer-events:none;z-index:50}
  /* pop-up bottom */
  .popup{position:fixed;left:50%;transform:translateX(-50%);bottom:28px;background:rgba(0,0,0,.9);color:var(--text);padding:14px 18px;border-radius:12px;min-width:260px;text-align:center;border:1px solid rgba(255,255,255,.04);display:none;z-index:9999}
  .popup h3{margin:0 0 6px 0;font-size:16px;color:var(--accent)}
  .popup p{margin:0;font-size:14px}
  /* responsive */
  @media(max-width:900px){.panel{width:280px}}
  @media(max-width:720px){.app{flex-direction:column}.panel{width:100%}}
</style>
</head>
<body>
<div class="app">
  <div class="board-wrap" id="boardWrap">
    <img id="boardImg" class="board" src="https://raw.githubusercontent.com/stephanelavallee89-crypto/Mon-jeux-/main/20251015_090213_0000.png" alt="Plateau">
    <!-- pawns will be inserted here -->
  </div>

  <div class="panel" id="panel">
    <h2>Party Game - Controls</h2>

    <div>
      <label for="numPlayers">Nombre de joueurs :</label>
      <select id="numPlayers" class="select">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
      </select>
    </div>

    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-size:13px;color:#aaa">Pions ‚Äî clique pour assigner au d√©part</div>
        <div style="font-size:12px;color:#777">S√©lection</div>
      </div>
      <div class="players" id="pawnsList">
        <!-- pawn buttons created by JS -->
      </div>
    </div>

    <div class="controls">
      <button id="startBtn" class="btn">Start</button>
      <button id="muteBtn" class="btn">üîä</button>
      <div style="flex:1"></div>
      <div class="dice btn" id="diceBtn" title="Lancer le d√©">üé≤</div>
    </div>

    <div class="status" id="statusBox">
      <div id="turnText">Aucun jeu en cours.</div>
      <div style="margin-top:8px;font-size:13px;color:#bdbdbd">Instructions : Choisis nombre de joueurs ‚Üí clique sur chaque pion pour le placer au d√©part ‚Üí Start ‚Üí chaque joueur lance le d√© quand c'est son tour.</div>
    </div>
  </div>
</div>

<!-- popup -->
<div class="popup" id="popup">
  <h3 id="popupTitle">ACTION</h3>
  <p id="popupText">Texte...</p>
</div>

<script>
/*
  Jeu complet en un fichier.
  - Sons et musique sont g√©n√©r√©s par WebAudio (pas de mp3 externes).
  - Positions des 25 cases sont d√©finies en % par rapport au wrap (approx).
  - Pions: 6 couleurs.
*/

///// --- Action / case data --- /////
const casesData = {
  1: {action:"Tout le monde se sert a boire !", popup:"sant√© !", sfx:"glass"},
  2: {action:"Fredone la chanson que te souffle le joueur a ta droite si les autres joueurs ne trouvent pas tu bois :)", popup:"Met l'ambiance !", sfx:"ambiance"},
  3: {action:"Embrasse le joueur a ta droite", popup:"smack", sfx:"kiss"},
  4: {action:"Pose une colle au joueur de ton choix s'il perd il boit sinon c'est toi ;)", popup:"Culture G", sfx:"ambiance"},
  5: {action:"Tout le monde trinque", popup:"tchin tchin", sfx:"glass"},
  6: {action:"Echange un vetement avec le joueur a ta gauche et faites un selfi", popup:"Echange", sfx:"ambiance"},
  7: {action:"Mime ce que te souffle le joueur de droite; si les autres joueurs ne trouvent pas tu bois ;)", popup:"Action!", sfx:"clap"},
  8: {action:"(case 8 - neutre)", popup:"", sfx:"ambiance"},
  9: {action:"Echange ton verre avec le joueur a ta droite", popup:"C'est bon... ou pas !", sfx:"lounge"},
  10:{action:"Designe ton joueur favoris", popup:"Love", sfx:"romantic"},
  11:{action:"Retour a la case depart !", popup:"A√èE", sfx:"fall"},
  12:{action:"Dessine ce que te souffle le joueur a ta gauche si les autres joueurs ne trouvent pas tu bois !", popup:"Draw", sfx:"ambiance"},
  13:{action:"Pose une colle au joueur de ton choix si il perd il boit sinon c'est toi ;)", popup:"Culture g", sfx:"ambiance"},
  14:{action:"Embrasse le joeur a ta gauche", popup:"Smak", sfx:"kiss"},
  15:{action:"Echange un vetement avec le joueur a ta droite et faites un selfi", popup:"Echange", sfx:"ambiance"},
  16:{action:"Passe ton tour ! Et bois un coup tant qu'a faire :)", popup:"stop!", sfx:"skid"},
  17:{action:"Echange ton verre avec le joueur a ta gauche", popup:"C'est bon...ou pas!", sfx:"lounge"},
  18:{action:"Dessine ce que te souffle le joueur a ta droite si les autres joueurs ne trouvent pas tu bois !", popup:"Draw", sfx:"ambiance"},
  19:{action:"avance de trois cases ... je pense que tu avais soif :)", popup:"tchou tchou glou glou", sfx:"train"},
  20:{action:"Fredonne la chanson que te souffle le joueur a ta gauche si les autres joueurs ne trouvent pas tu bois :)", popup:"Met l'ambiance !", sfx:"hum"},
  21:{action:"Pose une question os√© au joueur de ton choix s'il ne r√©pond pas il boit", popup:"Indiscretions", sfx:"coquin"},
  22:{action:"cul sec !", popup:"glou glou", sfx:"pour"},
  23:{action:"mime ce que te souffle le joueur a ta gauche si les autres joueurs ne trouvent pas tu bois ;)", popup:"Action!", sfx:"clap"},
  24:{action:"Pose une colle au joeur de ton choix si il perd il boit sinon c'est toi ;)", popup:"Culture g", sfx:"ambiance"},
  25:{action:"Tu as gagn√© le droit de demander le service que tu veux au joueur de ton choix", popup:"winner!!!", sfx:"win"}
};

///// --- Board case positions (percent) --- /////
// Approximative route around the board image (25 positions).
// Each position is {x%, y%} relative to boardWrap client rect.
const positions = [
  null,
  {x:50, y:85}, //1
  {x:62, y:82}, //2
  {x:74, y:75}, //3
  {x:82, y:65}, //4
  {x:86, y:52}, //5
  {x:82, y:40}, //6
  {x:74, y:30}, //7
  {x:62, y:22}, //8
  {x:50, y:18}, //9
  {x:36, y:22}, //10
  {x:26, y:30}, //11
  {x:18, y:40}, //12
  {x:14, y:52}, //13
  {x:18, y:65}, //14
  {x:26, y:75}, //15
  {x:36, y:82}, //16
  {x:48, y:84}, //17
  {x:50, y:72}, //18 (inner)
  {x:60, y:72}, //19
  {x:65, y:60}, //20
  {x:60, y:50}, //21
  {x:55, y:40}, //22
  {x:45, y:40}, //23
  {x:40, y:50}, //24
  {x:50, y:60}  //25 center-ish
];

///// --- Colors and players --- /////
const pawnColors = ["#e74c3c","#3498db","#2ecc71","#f39c12","#9b59b6","#e67e22"];
const pawns = []; // will hold player objects

///// --- DOM references --- /////
const boardWrap = document.getElementById('boardWrap');
const pawnsList = document.getElementById('pawnsList');
const startBtn = document.getElementById('startBtn');
const muteBtn = document.getElementById('muteBtn');
const diceBtn = document.getElementById('diceBtn');
const numPlayersSelect = document.getElementById('numPlayers');
const statusBox = document.getElementById('statusBox');
const turnText = document.getElementById('turnText');
const popup = document.getElementById('popup');
const popupTitle = document.getElementById('popupTitle');
const popupText = document.getElementById('popupText');
const boardImg = document.getElementById('boardImg');

///// --- WebAudio setup (synth music + sfx) --- /////
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
let masterGain = audioCtx.createGain();
masterGain.gain.value = 0.9;
masterGain.connect(audioCtx.destination);
let musicGain = audioCtx.createGain(); musicGain.gain.value = 0.6; musicGain.connect(masterGain);
let sfxGain = audioCtx.createGain(); sfxGain.gain.value = 0.9; sfxGain.connect(masterGain);
let isMuted = false;

function toggleMute(){
  isMuted = !isMuted;
  masterGain.gain.value = isMuted ? 0 : 0.9;
  muteBtn.textContent = isMuted ? "üîà" : "üîä";
}

/* Simple ambient/chill music generator:
   - A few slowly modulated oscillators and noise-based pads.
   - Played in loop while 'musicPlaying' true.
*/
let musicPlaying = false;
let musicNodes = [];
function startMusic(){
  if(musicPlaying) return;
  // resume audio context on user gesture
  if(audioCtx.state === 'suspended'){ audioCtx.resume(); }
  musicPlaying = true;
  // create a few detuned oscillators with slow LFOs
  const notes = [220, 261.63, 329.63]; // A3, C4, E4
  notes.forEach((freq,i)=>{
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq * (i===0?1: (i===1?0.5:2));
    const gain = audioCtx.createGain(); gain.gain.value = 0.0;
    // slight detune
    osc.detune.value = (i-1)*8;
    // slow amplitude LFO
    const lfo = audioCtx.createOscillator(); lfo.frequency.value = 0.05 + i*0.01; lfo.type='sine';
    const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.2;
    lfo.connect(lfoGain); lfoGain.connect(gain.gain);
    osc.connect(gain); gain.connect(musicGain);
    osc.start();
    lfo.start();
    musicNodes.push({osc,gain,lfo,lfoGain});
    // ramp up
    gain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 2 + i);
  });
  // low ambient noise/pad
  const bufferSize = 2*audioCtx.sampleRate;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++){ output[i] = (Math.random()*2-1)*0.02; }
  const noise = audioCtx.createBufferSource();
  noise.buffer = noiseBuffer; noise.loop = true;
  const nf = audioCtx.createBiquadFilter(); nf.type = 'lowpass'; nf.frequency.value = 900;
  noise.connect(nf); nf.connect(musicGain);
  noise.start();
  musicNodes.push({noise,nf});
}

function stopMusic(){
  musicNodes.forEach(n=>{
    if(n.osc){ try{ n.osc.stop(); }catch(e){} }
    if(n.lfo){ try{ n.lfo.stop(); }catch(e){} }
    if(n.noise){ try{ n.noise.stop(); }catch(e){} }
  });
  musicNodes=[];
  musicPlaying=false;
}

/* SFX helper functions (all short sounds synthesized)
   sfx id: 'glass','ambiance','kiss','clap','lounge','romantic','fall','skid','train','hum','coquin','pour','win'
*/
function playSfx(id, when=0){
  if(isMuted) return;
  const t = audioCtx.currentTime + when;
  switch(id){
    case 'glass':
      { const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(950,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t);
        g.gain.exponentialRampToValueAtTime(0.3,t+0.02);
        g.gain.exponentialRampToValueAtTime(0.001,t+1.2);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+1.3);
      } break;
    case 'ambiance':
      { const b = audioCtx.createOscillator(); b.type='sine'; b.frequency.setValueAtTime(220,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t);
        g.gain.linearRampToValueAtTime(0.08,t+0.02);
        g.gain.linearRampToValueAtTime(0.0,t+1.6);
        b.connect(g); g.connect(sfxGain);
        b.start(t); b.stop(t+1.6);
      } break;
    case 'kiss':
      { // short pop + high sparkle
        const o = audioCtx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(600,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.2,t);
        g.gain.exponentialRampToValueAtTime(0.0001,t+0.22);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+0.24);
        // sparkle
        const s = audioCtx.createOscillator(); s.type='sine'; s.frequency.setValueAtTime(1400,t);
        const sg = audioCtx.createGain(); sg.gain.setValueAtTime(0.05,t);
        sg.gain.exponentialRampToValueAtTime(0.0001,t+0.18);
        s.connect(sg); sg.connect(sfxGain);
        s.start(t); s.stop(t+0.18);
      } break;
    case 'clap':
      { // filtered noise burst
        const bufferSize = audioCtx.sampleRate*0.2;
        const nb = audioCtx.createBuffer(1,bufferSize,audioCtx.sampleRate);
        const data = nb.getChannelData(0);
        for(let i=0;i<bufferSize;i++){ data[i]=(Math.random()*2-1)*(1 - i/bufferSize); }
        const src = audioCtx.createBufferSource(); src.buffer=nb;
        const f = audioCtx.createBiquadFilter(); f.type='highpass'; f.frequency.value=800;
        src.connect(f); f.connect(sfxGain);
        src.start(t); src.stop(t+0.2);
      } break;
    case 'lounge':
      { const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(400,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t);
        g.gain.linearRampToValueAtTime(0.06,t+0.02);
        g.gain.linearRampToValueAtTime(0.0,t+1.2);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+1.2);
      } break;
    case 'romantic':
      { const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(520,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t);
        g.gain.linearRampToValueAtTime(0.08,t+0.02);
        g.gain.linearRampToValueAtTime(0,t+1.0);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+1.0);
      } break;
    case 'fall':
      { const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(600,t);
        o.frequency.linearRampToValueAtTime(120,t+0.8);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.4,t);
        g.gain.exponentialRampToValueAtTime(0.0001,t+1.2);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+1.2);
      } break;
    case 'skid':
      { const b = audioCtx.createOscillator(); b.type='sawtooth'; b.frequency.setValueAtTime(140,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.3,t);
        g.gain.exponentialRampToValueAtTime(0.0001,t+0.5);
        b.connect(g); g.connect(sfxGain);
        b.start(t); b.stop(t+0.5);
      } break;
    case 'train':
      { // whistle sweep
        const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(400,t);
        o.frequency.exponentialRampToValueAtTime(900,t+0.8);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.35,t);
        g.gain.exponentialRampToValueAtTime(0.0001,t+1.2);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+1.2);
      } break;
    case 'hum':
      { const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(200,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.1,t);
        g.gain.exponentialRampToValueAtTime(0.0001,t+1.0);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+1.0);
      } break;
    case 'coquin':
      { const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(350,t);
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.25,t);
        g.gain.exponentialRampToValueAtTime(0.0001,t+0.8);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+0.8);
      } break;
    case 'pour':
      { const bufferSize = audioCtx.sampleRate*0.5;
        const nb = audioCtx.createBuffer(1,bufferSize,audioCtx.sampleRate);
        const data = nb.getChannelData(0);
        for(let i=0;i<bufferSize;i++){ data[i]= (Math.random()*2-1) * (1 - Math.pow(i/bufferSize,1.7)) * 0.04; }
        const src = audioCtx.createBufferSource(); src.buffer=nb;
        const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1200;
        src.connect(f); f.connect(sfxGain);
        src.start(t); src.stop(t+0.5);
      } break;
    case 'win':
      { // small arpeggio
        const freqs = [660,880,990];
        freqs.forEach((f,i)=>{
          const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(f, t + i*0.12);
          const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, t + i*0.12);
          g.gain.exponentialRampToValueAtTime(0.25, t + i*0.12 + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, t + i*0.12 + 0.6);
          o.connect(g); g.connect(sfxGain);
          o.start(t + i*0.12); o.stop(t + i*0.12 + 0.8);
        });
      } break;
    default: break;
  }
}

///// --- Game state and functions --- /////
let gameStarted = false;
let numPlayers = parseInt(numPlayersSelect.value,10);
let currentPlayerIndex = 0; // index in pawns array
let turnOrder = []; // indices of players in order
let isAwaitingStartRoll = false;

function initPawns(){
  pawnsList.innerHTML = '';
  pawns.length = 0;
  for(let i=0;i<6;i++){
    const btn = document.createElement('div');
    btn.className = 'pawn';
    btn.style.background = pawnColors[i];
    btn.textContent = (i+1);
    btn.dataset.idx = i;
    btn.dataset.selected = 'false';
    btn.title = `Joueur ${i+1}`;
    btn.addEventListener('click', onPawnAssign);
    pawnsList.appendChild(btn);
    // create player object
    pawns.push({
      id:i+1,
      color:pawnColors[i],
      btn,
      pos:0, // 0 = not placed, 1..25 = case
      el:null // dom element on board
    });
  }
  renderPawnsOnBoard();
}

function renderPawnsOnBoard(){
  // remove existing displayed elements
  document.querySelectorAll('.pawn-on-board').forEach(n=>n.remove());
  pawns.forEach((p,i)=>{
    const el = document.createElement('div');
    el.className = 'pawn-on-board';
    el.style.background = p.color;
    el.textContent = p.id;
    el.style.display = 'none';
    boardWrap.appendChild(el);
    p.el = el;
  });
}

function onPawnAssign(e){
  const idx = parseInt(e.currentTarget.dataset.idx,10);
  // toggling assignment: if assigned -> unassign
  const player = pawns[idx];
  if(player.pos === 1){
    setStatus(`Joueur ${player.id} retir√© du d√©part.`);
    player.pos = 0;
    player.btn.dataset.selected = 'false';
    updateBoardPawn(player, false);
    return;
  }
  // Count how many players should play
  const should = parseInt(numPlayersSelect.value,10);
  const assigned = pawns.filter(p=>p.pos===1).length;
  if(assigned >= should){
    alert(`Tu as d√©j√† assign√© ${should} joueurs au d√©part. Pour changer, d√©sassignes d'abord un pion.`);
    return;
  }
  // assign to case 1 (depart)
  player.pos = 1;
  player.btn.dataset.selected = 'true';
  updateBoardPawn(player,true);
  setStatus(`Joueur ${player.id} assign√© sur la case D√©part.`);
}

function updateBoardPawn(player, show=true){
  if(!player.el) return;
  if(!show){ player.el.style.display='none'; return; }
  // place at position index (pos)
  const pos = positions[player.pos] || positions[1];
  player.el.style.left = pos.x + '%';
  player.el.style.top = pos.y + '%';
  player.el.style.display = 'flex';
}

function setStatus(txt){
  turnText.textContent = txt;
}

function showPopup(title,text){
  popupTitle.textContent = title;
  popupText.textContent = text;
  popup.style.display = 'block';
  // auto hide after 3s
  setTimeout(()=>{ popup.style.display = 'none'; }, 3000);
}

///// --- game flow handlers --- /////
startBtn.addEventListener('click', ()=>{
  // ensure audio resumed on click
  if(audioCtx.state === 'suspended'){ audioCtx.resume(); }
  if(gameStarted){
    setStatus('Jeu d√©j√† d√©marr√©.');
    return;
  }
  numPlayers = parseInt(numPlayersSelect.value,10);
  const assigned = pawns.filter(p=>p.pos===1).length;
  if(assigned < numPlayers){
    alert(`Assigne ${numPlayers} pions au d√©part (clique sur chaque pion).`);
    return;
  }
  // build turn order (only assigned players in order of pawn id)
  turnOrder = pawns.filter(p=>p.pos===1).slice(0,numPlayers).map(p=>p.id - 1);
  currentPlayerIndex = 0;
  gameStarted = true;
  // start music
  startMusic();
  setStatus(`Jeu d√©marr√©. Joueur ${pawns[turnOrder[0]].id} commence.`);
  showPopup(casesData[1].popup, casesData[1].action);
  playSfx(casesData[1].sfx);
  highlightCurrentPlayer();
  // dis/enable dice
  isAwaitingStartRoll = true;
});

function highlightCurrentPlayer(){
  // visual feedback in panel
  const idx = turnOrder[currentPlayerIndex];
  setStatus(`Tour: Joueur ${pawns[idx].id}`);
  // outline selected pawn button
  pawns.forEach(p=>p.btn.style.boxShadow='0 2px 6px rgba(0,0,0,.6)');
  pawns[idx].btn.style.boxShadow='0 0 0 4px rgba(241,196,15,0.12)';
}

diceBtn.addEventListener('click', ()=>{ 
  if(!gameStarted){ alert('Le jeu n\'a pas d√©marr√©. Clique sur Start.'); return; }
  // current player must be active (in order)
  const playerIdx = turnOrder[currentPlayerIndex];
  rollDiceFor(playerIdx);
});

function rollDiceFor(playerIdx){
  // random 1..6
  const roll = Math.floor(Math.random()*6)+1;
  diceBtn.textContent = `üé≤ ${roll}`;
  setStatus(`Joueur ${pawns[playerIdx].id} a fait ${roll}.`);
  playSfx('clap');
  movePawn(playerIdx, roll);
}

function movePawn(playerIdx, steps){
  const player = pawns[playerIdx];
  let target = player.pos + steps;
  if(target > 25) target = 25; // cap at end
  animateMove(player, player.pos, target, ()=>{
    // after move complete, handle landed case
    handleLandedCase(playerIdx);
  });
}

function animateMove(player, from, to, cb){
  if(from === 0) from = 1; // if not placed, teleport to 1 (shouldn't happen)
  let i = from;
  const stepDelay = 360;
  const nextStep = ()=>{
    i++;
    player.pos = i;
    updateBoardPawn(player,true);
    // play small step sfx
    playSfx('lounge');
    if(i < to){
      setTimeout(nextStep, stepDelay);
    } else {
      // final
      setTimeout(cb, 260);
    }
  };
  // starting immediate small move if from==to (still show)
  if(to <= from){
    player.pos = to;
    updateBoardPawn(player,true);
    setTimeout(cb, 200);
  } else {
    setTimeout(nextStep, stepDelay);
  }
}

function handleLandedCase(playerIdx){
  const p = pawns[playerIdx];
  const c = p.pos;
  const data = casesData[c] || {action:'Rien',popup:'',sfx:'ambiance'};
  // special rules
  if(c === 11){
    // return to start
    showPopup(data.popup, data.action);
    playSfx(data.sfx);
    setTimeout(()=>{
      p.pos = 1;
      updateBoardPawn(p,true);
      setStatus(`Joueur ${p.id} retourne au d√©part (case 11)`);
      // next player's turn
      nextTurn();
    }, 800);
    return;
  } else if(c === 19){
    // advance +3
    showPopup(data.popup, data.action);
    playSfx(data.sfx);
    // after short wait, advance additional 3
    setTimeout(()=>{
      const extra = 3;
      const target = Math.min(25, p.pos + extra);
      animateMove(p, p.pos, target, ()=>{
        // landed on new case, trigger it too
        const landed = p.pos;
        const dat2 = casesData[landed] || {action:'',popup:'',sfx:'ambiance'};
        showPopup(dat2.popup, dat2.action);
        playSfx(dat2.sfx);
        // then next turn
        if(landed===25){ victory(p); } else nextTurn();
      });
    }, 1100);
    return;
  } else {
    // normal
    showPopup(data.popup, data.action);
    playSfx(data.sfx);
    if(c === 25){ victory(p); return; }
  }
  // move to next player
  setTimeout(()=>{ nextTurn(); }, 800);
}

function nextTurn(){
  currentPlayerIndex = (currentPlayerIndex + 1) % turnOrder.length;
  highlightCurrentPlayer();
}

function victory(player){
  showPopup('WINNER!!!', `Joueur ${player.id} a gagn√© !`);
  playSfx('win');
  setStatus(`Fin de la partie ‚Äî Joueur ${player.id} gagne !`);
  // stop music after victory
  stopMusic();
  gameStarted = false;
}

///// --- initialize and helpers on load --- /////
initPawns();
setStatus('Pr√™t. Choisis nombre de joueurs et assigne les pions au d√©part.');

numPlayersSelect.addEventListener('change', ()=>{
  // if user reduces number, advise to unassign extras
  const want = parseInt(numPlayersSelect.value,10);
  setStatus(`Nombre de joueurs r√©gl√© √† ${want}. Assigne les ${want} pions au d√©part.`);
});

muteBtn.addEventListener('click', ()=>{ toggleMute(); });

/* place pawns initially off-board (hidden) */
window.addEventListener('resize', ()=>{ // reposition pawns in case of resize
  pawns.forEach(p=>{
    if(p.pos>0) updateBoardPawn(p,true);
  });
});

/* ensure audio context unlock on first user gesture (some mobile browsers require) */
document.addEventListener('click', function unlockAudio(){
  if(audioCtx.state === 'suspended') audioCtx.resume();
  document.removeEventListener('click', unlockAudio);
});
</script>
</body>
</html>
